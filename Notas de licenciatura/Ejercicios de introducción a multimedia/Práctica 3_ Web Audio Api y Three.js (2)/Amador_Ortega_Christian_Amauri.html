<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../../../../Working%20files/CHRISTIAN%20AMADOR%20ORTEGA/Propuesta%20de%20proyecto%20multimedia/main.css">
	</head>
	<body>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			
			
			//------------------
			THREE.Cache.enabled = true;
			
			var context;
			var sourceNode;
			var analyser;
			var analyser2;
			var b_setup=false;


			function setupSound() {
				if (! window.AudioContext) {
					if (! window.webkitAudioContext) {
						alert('no audiocontext found');
					}
					window.AudioContext = window.webkitAudioContext;
				}
				context = new AudioContext();

				// setup a analyzer
				analyser = context.createAnalyser();
				analyser.smoothingTimeConstant = 0.4;
				analyser.fftSize = 1024;

				analyser2 = context.createAnalyser();
				analyser2.smoothingTimeConstant = 0.4;
				analyser2.fftSize = 1024;
	
				// create a buffer source node
				sourceNode = context.createBufferSource();
				var splitter = context.createChannelSplitter();

				// connect the source to the analyser and the splitter
				sourceNode.connect(splitter);

				// connect one of the outputs from the splitter to
				// the analyser
				splitter.connect(analyser,0);
				splitter.connect(analyser2,1);

				// and connect to destination
				sourceNode.connect(context.destination);

				context = new AudioContext();
				b_setup=true;
			}


			function getAverageVolume(array) {
				var values = 0;
				var average;

				var length = array.length;

				// get all the frequency amplitudes
				for (var i = 0; i < length; i++) {
					values += array[i];
				}

				average = values / length;
				return average;
			}

			function playSound(buffer) {
				sourceNode.buffer = buffer;
				sourceNode.start(0);
			}

			// load the specified sound
			function loadSound(url) {
				var request = new XMLHttpRequest();
				request.open('GET', url, true);
				request.responseType = 'arraybuffer';

				// When loaded decode the data
				request.onload = function() {

					// decode the data
					context.decodeAudioData(request.response, function(buffer) {
					// when the audio is decoded play the sound
					playSound(buffer);
					}, onError);
				}
				request.send();
			}

			function onError(e) {
				console.log(e);
			}
			
			
			const canciones = new Map();
			canciones.set(0,"Grafiti.ogg");
			canciones.set(1,"Bombo.ogg");
			canciones.set(2,"Platillos.ogg");
			canciones.set(3,"Baquetas.ogg");
			canciones.set(4,"Copa.ogg");
			canciones.set(5,"Motor.ogg");
			canciones.set(6,"Balazo.ogg");
			canciones.set(7,"Gun-Load.ogg");
			canciones.set(8,"Aplauso.ogg");
			canciones.set(9,"Sirena.ogg");
			canciones.set(10,"SmokeAndMirrors.ogg");
			canciones.set(11,"Censura.ogg");
			
			
			/*
			var context;
			var sourceNode;
			var analyser;
			var analyser2;
			var b_setup=false;*/
			var rfrsh = 0;
			
			function updateText(){
				
				var array = new Uint8Array(analyser.frequencyBinCount);
				analyser.getByteFrequencyData(array);
				var average = getAverageVolume(array);
				
				var array2 = new Uint8Array(analyser2.frequencyBinCount);
				analyser2.getByteFrequencyData(array2);
				var average2 = getAverageVolume(array2);
				
				group.scale.y= 1;
				if ( (group.scale.y=average/20) < 0.6 ) { 
					group.scale.y= 0.6;
					//group.scale.x= 1;
					scene.background = new THREE.Color(0x002e56);
					
				}else if ( (group.scale.y=average/20) > 0.5 && (group.scale.y=average/20 < 1.5)){
					group.scale.y=average/20;
					//group.scale.x= average/60 ;
					scene.background = new THREE.Color(0x113f67);
				}else if ( (group.scale.y=average/20) > 1.4 && (group.scale.y=average/20 < 3)){
					group.scale.y=(average/40);
					//group.scale.x= average/22 ;
					scene.background = new THREE.Color(0x224f78);
				}else if ( (group.scale.y=average/20) > 2.9 && (group.scale.y=average/20 < 4.7)){
					group.scale.y=(average/60);
					//group.scale.x= average/25 ;
					scene.background = new THREE.Color(0x335f89);
				}else if ( group.scale.y=average/20 > 4.6 ){
					scene.background = new THREE.Color(0x446f9a);
					
					//clr = 0xffff00;
					//group.scale.x= average/27 ;
					group.scale.y=1.7;
				}
				
				
				rfrsh = rfrsh+1;
				if (rfrsh == 5 ){
					refresh_animation();
					rfrsh = 0;
				}
				
				
				
			}
			
			//------------------
			

			let camera, scene, renderer;
			let mesh1, mesh2, mesh3, mesh4, mesh5, mesh6, mesh7, mesh8, mesh9,mesh10,mesh11,meshsng;
			let controls;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.up.set( 0, 0, 1 );
				camera.position.set( - 100, - 250, 100 );
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x060606);

				const texture1 = new THREE.TextureLoader().load( 'textures/Bombo.jpeg' );
				const t1 = new THREE.MeshBasicMaterial( { map: texture1 } );
				const cubo1 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh1 = new THREE.Mesh( cubo1, t1 );
				
				scene.add( mesh1 );
				mesh1.position.set(-250,-60,0);
				
				
				
				const texture2 = new THREE.TextureLoader().load( 'textures/Platillos.jpeg' );
				const t2 = new THREE.MeshBasicMaterial( { map: texture2 } );
				const cubo2 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh2 = new THREE.Mesh( cubo2, t2 );
				scene.add( mesh2 );
				mesh2.position.set(-200,-60,0);
				
				
				const texture3 = new THREE.TextureLoader().load( 'textures/Baquetas.jpeg' );
				const t3 = new THREE.MeshBasicMaterial( { map: texture3 } );
				const cubo3 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh3 = new THREE.Mesh( cubo3, t3 );
				scene.add( mesh3 );
				mesh3.position.set(-150,-60,0);
				
				
				const texture4 = new THREE.TextureLoader().load( 'textures/Copa.jpeg' );
				const t4 = new THREE.MeshBasicMaterial( { map: texture4 } );
				const cubo4 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh4 = new THREE.Mesh( cubo4, t4 );
				scene.add( mesh4 );
				mesh4.position.set(-100,-60,0);
				
				
				const texture5 = new THREE.TextureLoader().load( 'textures/Motor.jpeg' );
				const t5 = new THREE.MeshBasicMaterial( { map: texture5 } );
				const cubo5 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh5 = new THREE.Mesh( cubo5, t5 );
				scene.add( mesh5 );
				mesh5.position.set( -50,-60,0);
				
				
				const texture6 = new THREE.TextureLoader().load( 'textures/Balazo.jpeg' );
				const t6 = new THREE.MeshBasicMaterial( { map: texture6 } );
				const cubo6 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh6 = new THREE.Mesh( cubo6, t6 );
				scene.add( mesh6 );
				mesh6.position.set(0,-60,0);
				
				
				const texture7 = new THREE.TextureLoader().load( 'textures/Re-load.jpeg' );
				const t7 = new THREE.MeshBasicMaterial( { map: texture7 } );
				const cubo7 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh7 = new THREE.Mesh( cubo7, t7 );
				scene.add( mesh7 );
				mesh7.position.set(50,-60,0);
				
				//
				const texture8 = new THREE.TextureLoader().load( 'textures/Aplauso.jpeg' );
				const t8 = new THREE.MeshBasicMaterial( { map: texture8 } );
				const cubo8 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh8 = new THREE.Mesh( cubo8, t8 );
				scene.add( mesh8 );
				mesh8.position.set( 100,-60,0);
				
				
				const texture9 = new THREE.TextureLoader().load( 'textures/Sirena.jpeg' );
				const t9 = new THREE.MeshBasicMaterial( { map: texture9 } );
				const cubo9 = new THREE.BoxGeometry( 40, 40, 40 );
				mesh9 = new THREE.Mesh( cubo9, t9 );
				scene.add( mesh9 );
				mesh9.position.set( 150,-60,0);
				
				
				const texture10= new THREE.TextureLoader().load( 'textures/Grafiti.jpg' );
				const t10= new THREE.MeshBasicMaterial( { map: texture10 } );
				const cubo10= new THREE.BoxGeometry( 40, 40, 40 );
				mesh10= new THREE.Mesh( cubo10, t10 );
				scene.add( mesh10);
				mesh10.position.set( 200,-60,0);
				
				
				const texture11= new THREE.TextureLoader().load( 'textures/Censura.jpg' );
				const t11= new THREE.MeshBasicMaterial( { map: texture11 } );
				const cubo11= new THREE.BoxGeometry( 40, 40, 40 );
				mesh11= new THREE.Mesh( cubo11, t11 );
				scene.add( mesh11);
				mesh11.position.set( 250,-60,0);
				
				
				
				const texturesng= new THREE.TextureLoader().load( 'textures/Making Mirrors.jpeg' );
				const tsng= new THREE.MeshBasicMaterial( { map: texturesng } );
				const cubosng= new THREE.BoxGeometry( 120, 120, 120 );
				meshsng= new THREE.Mesh( cubosng, tsng );
				scene.add( meshsng);
				meshsng.position.set( -5,60,40);
				
				
				
				
				

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//
				
				
				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 50;
				controls.maxDistance = 400;
				controls.enablePan = false;
				controls.update();

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				window.addEventListener( 'resize', onWindowResize );
				
				
				window.onload = function() {
					setupSound();
				};
				
				document.addEventListener( 'keypress', onDocumentKeyPress );
				mesh1.addEventListener( 'click', reproducirSonido1 ); // intento de evento para los cubos

			}
			
			function onDocumentKeyPress( event ) { // C I T A   A L E A T O R I A . . . . . . (mediante el teclado)
				const keyCode = event.which;
				
				// tecla de borrado
				if ( keyCode == 8 ) {
					event.preventDefault();
				} else {
					setupSound();
					//loadSound(canciones.get(1));
					if (keyCode == 13) loadSound(canciones.get(10));// enter (canción)
					if (keyCode == 49)  loadSound(canciones.get(1));// 1 (bombo)
					if (keyCode == 50)  loadSound(canciones.get(2));// 2 (platillos)
					if (keyCode == 51)  loadSound(canciones.get(3));// 3 (baquetas)
					if (keyCode == 52)  loadSound(canciones.get(4));// 4 (copa)
					if (keyCode == 53)  loadSound(canciones.get(5));// 5 (motor)
					if (keyCode == 54) loadSound(canciones.get(6)); // 6 (balazo)
					if (keyCode == 55)  loadSound(canciones.get(7));// 7 (re-load)
					if (keyCode == 56)  loadSound(canciones.get(8));// 8 (aplauso)
					if (keyCode == 57)  loadSound(canciones.get(9));// 9 (sirena)
					if (keyCode == 48)  loadSound(canciones.get(0));// 0 (grafiti)
					if (keyCode == 32)  loadSound(canciones.get(11));// c (censura)
					
					
				}
				
		
				

			}
			
			// intento de evento con click por cada cubo (no se hicieron más intentos porque este prototipo falló (y muchos otros))
			function reproducirSonido1(event){
				setupSound();
				loadSound(canciones.get(1));
					
			}
			

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
