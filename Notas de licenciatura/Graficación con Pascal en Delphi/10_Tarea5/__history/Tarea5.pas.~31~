unit Tarea5;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls;

type
  TForm1 = class(TForm)
    Panel1: TPanel;
    Panel2: TPanel;
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Button4: TButton;
    Button5: TButton;
    Button6: TButton;
    Button7: TButton;
    Button8: TButton;
    Button9: TButton;
    Button10: TButton;
    Button11: TButton;
    Button12: TButton;
    Image1: TImage;
    Label1: TLabel;
    Label2: TLabel;
    OpenDialog1: TOpenDialog;
    Panel3: TPanel;
    Button13: TButton;
    Button14: TButton;
    Button15: TButton;
    Button16: TButton;
    Label3: TLabel;
    Button17: TButton;
    Button18: TButton;
    Label4: TLabel;
    Label5: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure Habilitar();
    procedure CleanImage();
    procedure Button9Click(Sender: TObject);
    procedure Button10Click(Sender: TObject);
    procedure Button11Click(Sender: TObject);
    procedure Button12Click(Sender: TObject);
    procedure Button7Click(Sender: TObject);
    procedure Button8Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure Button5Click(Sender: TObject);
    procedure Button6Click(Sender: TObject);
    procedure Button15Click(Sender: TObject);
    procedure Button16Click(Sender: TObject);
    procedure Button13Click(Sender: TObject);
    procedure Button14Click(Sender: TObject);
    procedure Button18Click(Sender: TObject);
    procedure Button17Click(Sender: TObject);
    Procedure CleanData();
  private
    { Private declarations }
  public
    { Public declarations }
  end;
type
TPoint3D = packed record
x: Real;
y: Real;
z: Real;
end;

const
TamFig = 1;
Lim_tubos = 600; //-> Límite máximo de 60 tubos y mangueras :(
Lim_prismas = 1600; //-> Límite máximo de 160 prismas :(

{
La manera en la que se manejará la información será de la siguiente:

Así como un cubo requiere 10 puntos (X, Y, Z) y eso basta para efectuar las
operaciones posibles (rotación, traslación, etc...), podemos definir una Red de
prismas de tamaño N*10, donde N es el número de prismas que deseamos tener y el
10 representa los 10 puntos que cada prisma (en este caso cuadrangular) requiere
es decir... en un arreglo de 1600 TPoint3D'S tenemos lo necesario para almacenar
hasta 160 prismas, y cada 10 TPoint3D'S simbolizan un prisma particular
y funciona igual para los tubos (también son prismas pero delgaditos y estirados) jajajaj

}

var
Prismas : Array[1..Lim_prismas] of TPoint3D;
tubo : Array[1..Lim_tubos] of TPoint3D;
tipo_prismas : Array[1..round(Lim_prismas/10)] of integer;   // en este guardaremos los tipos de componente que son los prismas (casa, edificio, etc.)
tipo_tubos : Array[1..round(Lim_tubos/10)] of boolean;       // en este guardaremos los tipos de componente que son los tubos (tubo o manguera)
n_prismas , n_tubos , razon_de_movimiento: integer;
P, Q : TPoint;
xAux, yAux, zAux,OjoAObjeto,D : Real;

var
  Form1: TForm1;
  listo_para_pintar : boolean;

implementation

{$R *.dfm}

// Rotaciones, Proyección perspectiva, escala, traslación y TODO está basado en
// ideas y >> CÓDIGOS << vistos en clase.

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] R O T A R   X
procedure TForm1.Button1Click(Sender: TObject);
Var
i: integer;
alfa : Real;
begin
alfa := (15*Pi) / 180.0;
for i := 1 to n_prismas*10 do begin
  yAux := (Prismas[i].y * COS( -alfa )) + (Prismas[i].z * SIN( -alfa ));
  zAux := -(Prismas[i].y * SIN( -alfa )) + (Prismas[i].z * COS( -alfa ));
  Prismas[i].y := yAux;
  Prismas[i].z := zAux;
end;
for i := 1 to n_tubos*10 do begin
  yAux := (Tubo[i].y * COS( -alfa )) + (Tubo[i].z * SIN( -alfa ));
  zAux := -(Tubo[i].y * SIN( -alfa )) + (Tubo[i].z * COS( -alfa ));
  Tubo[i].y := yAux;
  Tubo[i].z := zAux;
end;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] R O T A R   -X
procedure TForm1.Button2Click(Sender: TObject);
Var
i: integer;
alfa : Real;
begin
alfa := (15*Pi) / 180.0;
for i := 1 to n_prismas*10 do begin
  yAux := (Prismas[i].y * COS( alfa )) + (Prismas[i].z * SIN( alfa ));
  zAux := -(Prismas[i].y * SIN( alfa )) + (Prismas[i].z * COS( alfa ));
  Prismas[i].y := yAux;
  Prismas[i].z := zAux;
end;
for i := 1 to n_Tubos*10 do begin
  yAux := (Tubo[i].y * COS( alfa )) + (Tubo[i].z * SIN( alfa ));
  zAux := -(Tubo[i].y * SIN( alfa )) + (Tubo[i].z * COS( alfa ));
  Tubo[i].y := yAux;
  Tubo[i].z := zAux;
end;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] R O T A R   Y
procedure TForm1.Button3Click(Sender: TObject);
Var
i: integer;
alfa : Real;
begin
alfa := (15*Pi) / 180.0;
for i := 1 to n_prismas*10 do begin
  xAux := (Prismas[i].x * COS( -alfa )) + (Prismas[i].z * SIN( -alfa ));
  zAux := -(Prismas[i].x * SIN( -alfa )) + (Prismas[i].z * COS( -alfa ));
  Prismas[i].x := xAux;
  Prismas[i].z := zAux;
end;
for i := 1 to n_Tubos*10 do begin
  xAux := (Tubo[i].x * COS( -alfa )) + (Tubo[i].z * SIN( -alfa ));
  zAux := -(Tubo[i].x * SIN( -alfa )) + (Tubo[i].z * COS( -alfa ));
  Tubo[i].x := xAux;
  Tubo[i].z := zAux;
end;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] R O T A R   -Y
procedure TForm1.Button4Click(Sender: TObject);
Var
i: integer;
alfa : Real;
begin
alfa := (15*Pi) / 180.0;
for i := 1 to n_prismas*10 do begin
  xAux := (Prismas[i].x * COS( alfa )) + (Prismas[i].z * SIN( alfa ));
  zAux := -(Prismas[i].x * SIN( alfa )) + (Prismas[i].z * COS( alfa ));
  Prismas[i].x := xAux;
  Prismas[i].z := zAux;
end;
for i := 1 to n_Tubos*10 do begin
  xAux := (Tubo[i].x * COS( alfa )) + (Tubo[i].z * SIN( alfa ));
  zAux := -(Tubo[i].x * SIN( alfa )) + (Tubo[i].z * COS( alfa ));
  Tubo[i].x := xAux;
  Tubo[i].z := zAux;
end;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] R O T A R   Z
procedure TForm1.Button5Click(Sender: TObject);
Var
i: integer;
alfa : Real;
begin
alfa := (15*Pi) / 180.0;
for i := 1 to n_prismas*10 do begin
  xAux := (Prismas[i].x * COS( -alfa )) + (Prismas[i].y * SIN( -alfa ));
  yAux := -(Prismas[i].x * SIN( -alfa )) + (Prismas[i].y * COS( -alfa ));
  Prismas[i].x := xAux;
  Prismas[i].y := yAux;
end;
for i := 1 to n_Tubos*10 do begin
  xAux := (Tubo[i].x * COS( -alfa )) + (Tubo[i].y * SIN( -alfa ));
  yAux := -(Tubo[i].x * SIN( -alfa )) + (Tubo[i].y * COS( -alfa ));
  Tubo[i].x := xAux;
  Tubo[i].y := yAux;
end;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] R O T A R   -Z
procedure TForm1.Button6Click(Sender: TObject);
Var
i: integer;
alfa : Real;
begin
alfa := (15*Pi) / 180.0;
for i := 1 to n_prismas*10 do begin
  xAux := (Prismas[i].x * COS( alfa )) + (Prismas[i].y * SIN( alfa ));
  yAux := -(Prismas[i].x * SIN( alfa )) + (Prismas[i].y * COS( alfa ));
  Prismas[i].x := xAux;
  Prismas[i].y := yAux;
end;
for i := 1 to n_Tubos*10 do begin
  xAux := (Tubo[i].x * COS( alfa )) + (Tubo[i].y * SIN( alfa ));
  yAux := -(Tubo[i].x * SIN( alfa )) + (Tubo[i].y * COS( alfa ));
  Tubo[i].x := xAux;
  Tubo[i].y := yAux;
end;
Button10Click(Sender);
end;

//[][][][][][][][][][][][][][][][][][][][][][][][][][][][][] A C E R C A R S E
procedure TForm1.Button7Click(Sender: TObject);
begin
OjoAObjeto := OjoAObjeto/1.10;
Button10Click(Sender);
razon_de_movimiento := razon_de_movimiento - 2;
end;

//[][][][][][][][][][][][][][][][][][][][][][][][][][][][][]  A L E J A R S E
procedure TForm1.Button8Click(Sender: TObject);
begin
OjoAObjeto := OjoAObjeto*1.10;
Button10Click(Sender);
razon_de_movimiento := razon_de_movimiento + 2;
end;

// convenciones del autor:
// de la tarea 4, el arrgelo de imágenes y el arreglo de líneas tienen
// ambos un campo: ' t ', éste determina el tipo de componente que un
// componente es. Los posibles valores de t se traducen de la siguiente forma:

//        para                  para
//  --- prismas: ---       --- tubos: ---
// 1 = distribuidores      1  = Tubos     (aquí usará el booleano True)
// 2 = casas               2 = Mangueras  (aquí usará el booleano False)
// 3 = edificios
// 4 = bombas
// 5 = medidores
// 6 = llaves

//[][][][][][][][][][][][][][][][][][][][][][][][][][][][][] A B R I R   R E D
procedure TForm1.Button9Click(Sender: TObject);
var
  I , Maxy, maxex , Miny, Minex, altura: integer;
  fl : TextFile ;
  d1,d2,d3,d4,d5,d6: integer ;
begin
if (Listo_Para_Pintar = True) then CleanData();

if (opendialog1.Execute) then begin
  Assignfile(fl, opendialog1.FileName);
  Reset(fl);
  d6 := 0;
  while (  d6 <> 2524) do begin  // Comenzamos a leer datos referentes a los Tubos Y mangueras
    Readln(fl,d1,d2,d3,d4,d5,d6);
    if (d6 <> 2524) then begin//d6 = 2524 es el código que indica que ya no hay más Tubos/Mangueras que leer
      // Define el tipo de componente que será tubos[i] dados los datos que lee del archivo
      if( d6 = 1) then tipo_tubos[n_tubos] := True else tipo_tubos[n_tubos] := False;

      // Guarda las coordenadas del Tubo[i] dados los datos que leé del archivo
      Tubo[(n_tubos*10)-9].x := +TamFig + d1; Tubo[(n_tubos*10)-9].y := +TamFig + d2 ; Tubo[(n_tubos*10)-9].z := 0;
      Tubo[(n_tubos*10)-8].x := +TamFig + d1; Tubo[(n_tubos*10)-8].y := -TamFig + d2; Tubo[(n_tubos*10)-8].z := 0;
      Tubo[(n_tubos*10)-7].x := -TamFig + d3; Tubo[(n_tubos*10)-7].y := -TamFig + d4; Tubo[(n_tubos*10)-7].z := 0;
      Tubo[(n_tubos*10)-6].x := -TamFig + d3; Tubo[(n_tubos*10)-6].y := +TamFig + d4; Tubo[(n_tubos*10)-6].z :=0;
      Tubo[(n_tubos*10)-5].x := +TamFig + d1; Tubo[(n_tubos*10)-5].y := +TamFig + d2; Tubo[(n_tubos*10)-5].z := 0;
      Tubo[(n_tubos*10)-4].x := +TamFig + d1; Tubo[(n_tubos*10)-4].y := +TamFig + d2; Tubo[(n_tubos*10)-4].z := -TamFig;
      Tubo[(n_tubos*10)-3].x := +TamFig + d1; Tubo[(n_tubos*10)-3].y := -TamFig + d2; Tubo[(n_tubos*10)-3].z := -TamFig;
      Tubo[(n_tubos*10)-2].x := -TamFig + d3; Tubo[(n_tubos*10)-2].y := -TamFig + d4; Tubo[(n_tubos*10)-2].z := -TamFig;
      Tubo[(n_tubos*10)-1].x := -TamFig + d3; Tubo[(n_tubos*10)-1].y := +TamFig + d4; Tubo[(n_tubos*10)-1].z := -TamFig;
      Tubo[(n_tubos*10)-0].x := +TamFig + d1; Tubo[(n_tubos*10)-0].y := +TamFig + d2; Tubo[(n_tubos*10)-0].z := -TamFig;

      // Iteramos el contador de Tubos
      n_tubos := n_tubos+1;
    end else begin // Comenzamos a leer datos referentes a los prismas
      while not EoF(fl) do begin
        Readln(fl,d1,d2,d3,d4);
        // Define el tipo de componente que será Prismas[i] dados los datos que lee del archivo
        case d4 of
          1: begin altura := 20 ;  tipo_prismas[n_prismas] := 1 end;  // distribuidor
          2: begin altura := 100 ; tipo_prismas[n_prismas] := 2 end; // casas
          3: begin altura := 200 ; tipo_prismas[n_prismas] := 3 end; // edificio
          4: begin altura := 40 ;  tipo_prismas[n_prismas] := 4 end; // bombas
          5: begin altura := 40 ;  tipo_prismas[n_prismas] := 5 end; // medidores
          6: begin altura := 10 ;  tipo_prismas[n_prismas] := 6 end; // llaves
        end;

        // Guarda las coordenadas del Prisma[i] dados los datos que lee del archivo
        Prismas[(n_prismas*10)-9].x := +TamFig + d1+80; Prismas[(n_prismas*10)-9].y := +TamFig + d2+80;   Prismas[(n_prismas*10)-9].z := 0;
        Prismas[(n_prismas*10)-8].x := +TamFig + d1+80; Prismas[(n_prismas*10)-8].y := -TamFig + d2;      Prismas[(n_prismas*10)-8].z := 0;
        Prismas[(n_prismas*10)-7].x := -TamFig + d1;    Prismas[(n_prismas*10)-7].y := -TamFig + d2;      Prismas[(n_prismas*10)-7].z := 0;
        Prismas[(n_prismas*10)-6].x := -TamFig + d1;    Prismas[(n_prismas*10)-6].y := +TamFig + d2+ 80;  Prismas[(n_prismas*10)-6].z := 0;
        Prismas[(n_prismas*10)-5].x := +TamFig + d1+80; Prismas[(n_prismas*10)-5].y := +TamFig + d2+80;   Prismas[(n_prismas*10)-5].z := 0;
        Prismas[(n_prismas*10)-4].x := +TamFig + d1+80; Prismas[(n_prismas*10)-4].y := +TamFig + d2+80;   Prismas[(n_prismas*10)-4].z := +TamFig - altura;
        Prismas[(n_prismas*10)-3].x := +TamFig + d1+80; Prismas[(n_prismas*10)-3].y := -TamFig + d2;      Prismas[(n_prismas*10)-3].z := +TamFig - altura;
        Prismas[(n_prismas*10)-2].x := -TamFig + d1;    Prismas[(n_prismas*10)-2].y := -TamFig + d2;      Prismas[(n_prismas*10)-2].z := +TamFig - altura;
        Prismas[(n_prismas*10)-1].x := -TamFig + d1;    Prismas[(n_prismas*10)-1].y := +TamFig + d2 + 80; Prismas[(n_prismas*10)-1].z := +TamFig - altura;
        Prismas[(n_prismas*10)-0].x := +TamFig + d1+80; Prismas[(n_prismas*10)-0].y := +TamFig + d2+80;   Prismas[(n_prismas*10)-0].z := +TamFig - altura;

        // Iteramos el contador de Prismas
        n_prismas := n_prismas+1;
      end;
    end;
  end;
  // terminando de llenar nuestros arrrays con los datos leídos de los archivos,
  // cerramos el "fl"
  CloseFile(fl);

  //variables de proyeccion perspectiva
  OjoAObjeto := 40*4;
  D := 40*2;
  //Transformación de escala
  for I := 1 to n_prismas*10 do begin // para prismas
    Prismas[i].x := Prismas[i].x * 20;
    Prismas[i].y := Prismas[i].y * 20;
    Prismas[i].z := Prismas[i].z * 20;
  end;
  for I := 1 to n_tubos*10 do begin  // para tubos y mangueras
    Tubo[i].x := Tubo[i].x * 20;
    Tubo[i].y := Tubo[i].y * 20;
    Tubo[i].z := Tubo[i].z * 20;
  end;

  maxy := 1; maxex := 1;
  if (listo_para_pintar = false) then Habilitar();
  // obtenemos maxy, maxex, minex y miny para hacer la traslación correcta después.
  // la traslación correcta deja el centro de la red en el origen.
  for I := 1 to n_prismas do if (prismas[i].x > maxex) then maxex := round(prismas[i].x);
  for I := 1 to n_prismas do if (prismas[i].y > maxy) then maxy := round(prismas[i].y);
  for I := 1 to n_tubos   do if (tubo[i].x > maxex) then maxex := round(tubo[i].x);
  for I := 1 to n_tubos   do if (tubo[i].y > maxy) then maxy := round(tubo[i].y);
  Minex := Maxex;   Miny := Maxy;
  for I := 1 to n_prismas do if (prismas[i].x < minex) then minex := round(prismas[i].x);
  for I := 1 to n_prismas do if (prismas[i].y < miny) then miny := round(prismas[i].y);
  for I := 1 to n_tubos   do if (tubo[i].x < minex) then minex := round(tubo[i].x);
  for I := 1 to n_tubos   do if (tubo[i].y < miny) then miny := round(tubo[i].y);

  Maxex := Maxex - Minex;
  Maxy := Maxy + Miny;
  maxex := maxex*3;

  for i := 1 to n_prismas*10 do begin // aplicamos la traslación para los prismas...
    Prismas[i].x := Prismas[i].x - round(maxex/2);
    Prismas[i].y := Prismas[i].y - round(maxy/2);
  end;
  for i := 1 to n_tubos*10 do begin // aplicamos la traslación para los tubos...
    Tubo[i].x := Tubo[i].x - round(maxex/2);
    Tubo[i].y := Tubo[i].y - round(maxy/2);
  end;

  // Damos "Formato" a la presentación de la red Rotando y alejando lo
  // pertinente para que lo primero que se vea no sea una deformidad
  //for I := 1 to 3 do Button2Click(Sender);
  for I := 1 to 44 do Button8Click(Sender);
  for I := 1 to 14 do Button13Click(Sender);

end else showmessage('Debes seleccionar una Red para utilizar el visor');

end;

//[][][][][][][][][][][][][][][][][][][][][][][][][][][][] P I N T A R   R E D
procedure TForm1.Button10Click(Sender: TObject);

procedure Perspectiva( x, y, z: Real; var xP, yP : Integer );
var
xAux, yAux, zAux : Real;
begin
zAux := z + OjoAObjeto;
xAux := (x * D) / zAux;
xP := Round(xAux) + 300;
yAux := (y * D) / zAux;
yP := Round(yAux) + 300;
end;

var
i , j: integer;
begin
CleanImage();
for j := 1 to n_prismas do begin
   // seleccionamos el color segun el tipo de componente
  case tipo_prismas[j] of
    1: Image1.Canvas.Pen.Color := clolive;// distribuidor
    2: Image1.Canvas.Pen.Color := ClLime; // casa
    3: Image1.Canvas.Pen.Color := ClRed ; // edificio
    4: Image1.Canvas.Pen.Color := claqua; // bomba
    5: Image1.Canvas.Pen.Color := Clblack;// medidor
    6: Image1.Canvas.Pen.Color := Clgray; // llave
  end;
  for i := (j*10)-9 to (j*10)-6 do begin // Pinta el Piso del Prisma i
    Perspectiva( Prismas[i].x, Prismas[i].y, Prismas[i].z, P.x, P.y );
    Perspectiva( Prismas[i+1].x, Prismas[i+1].y, Prismas[i+1].z, Q.x, Q.y );
    Image1.Canvas.MoveTo(P.x, P.y);
    Image1.Canvas.LineTo(Q.x, Q.y);
  end;
  for i := (j*10)-4 to (j*10)-1 do begin // Pinta el Techo del Prisma i
    Perspectiva( Prismas[i].x, Prismas[i].y, Prismas[i].z, P.x, P.y );
    Perspectiva( Prismas[i+1].x, Prismas[i+1].y, Prismas[i+1].z, Q.x, Q.y );
    Image1.Canvas.MoveTo(P.x, P.y);
    Image1.Canvas.LineTo(Q.x, Q.y);
  end;
  for i := (j*10)-9 to (j*10)-6 do begin // Pinta las Paredes del prisma i (Aristas)
    Perspectiva( Prismas[i].x, Prismas[i].y, Prismas[i].z, P.x, P.y );
    Perspectiva( Prismas[i+5].x, Prismas[i+5].y, Prismas[i+5].z, Q.x, Q.y );
    Image1.Canvas.MoveTo(P.x, P.y);
    Image1.Canvas.LineTo(Q.x, Q.y);
  end;
// seleccionamos el color segun el tipo de componente //      (debe ser naranja)
if(tipo_tubos[j] = True) then Image1.Canvas.Pen.Color := CLyellow else Image1.Canvas.Pen.Color := clblack;
  for i := (j*10)-9 to (j*10)-6 do begin // Pinta el Piso del tubo o manguera i
    Perspectiva( Tubo[i].x, Tubo[i].y, Tubo[i].z, P.x, P.y );
    Perspectiva( Tubo[i+1].x, Tubo[i+1].y, Tubo[i+1].z, Q.x, Q.y );
    Image1.Canvas.MoveTo(P.x, P.y);
    Image1.Canvas.LineTo(Q.x, Q.y);
  end;
  for i := (j*10)-4 to (j*10)-1 do begin // Pinta el Techo del tubo o manguera i
    Perspectiva( Tubo[i].x, Tubo[i].y, Tubo[i].z, P.x, P.y );
    Perspectiva( Tubo[i+1].x, Tubo[i+1].y, Tubo[i+1].z, Q.x, Q.y );
    Image1.Canvas.MoveTo(P.x, P.y);
    Image1.Canvas.LineTo(Q.x, Q.y);
  end;
  for i := (j*10)-9 to (j*10)-6 do begin // Pinta las Paredes del tubo o manguera i (Aristas)
    Perspectiva( Tubo[i].x, Tubo[i].y, Tubo[i].z, P.x, P.y );
    Perspectiva( Tubo[i+5].x, Tubo[i+5].y, Tubo[i+5].z, Q.x, Q.y );
    Image1.Canvas.MoveTo(P.x, P.y);
    Image1.Canvas.LineTo(Q.x, Q.y);
  end;
end;
Image1.Canvas.Pen.Color := clblack;
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] A U T O R
procedure TForm1.Button11Click(Sender: TObject);
begin
Showmessage('Autor: Un Mapache');
Showmessage('....(     Christian Amauri Amador Ortega     )');
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] S A L I R
procedure TForm1.Button12Click(Sender: TObject);
begin
Close();
end;

// " /\ ", " < ", " > ", " V " son herramientas extra que nos pueden ayudar
// a desplazarnos por el mapa, cada uno utiliza la traslación 3D en toda la red
// en la dirección hacia la que el botón indica, y esto da la ilusión de que
// nos movemos por la red.

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] "   /\  "
procedure TForm1.Button13Click(Sender: TObject);
var i : integer;
begin
for i := 1 to n_prismas*10 do  Prismas[i].y := Prismas[i].y - razon_de_movimiento;
for i := 1 to n_tubos*10 do tubo[i].y := Tubo[i].y - razon_de_movimiento;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] "   V   "
procedure TForm1.Button14Click(Sender: TObject);
var i : integer;
begin
for i := 1 to n_prismas*10 do  Prismas[i].y := Prismas[i].y + razon_de_movimiento;
for i := 1 to n_tubos*10 do tubo[i].y := Tubo[i].y + razon_de_movimiento;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] "   <   "
procedure TForm1.Button15Click(Sender: TObject);
var i : integer;
begin
for i := 1 to n_prismas*10 do  Prismas[i].x := Prismas[i].x + razon_de_movimiento;
for i := 1 to n_tubos*10 do tubo[i].x := Tubo[i].x + razon_de_movimiento;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] "   >   "
procedure TForm1.Button16Click(Sender: TObject);
var i : integer;
begin
for i := 1 to n_prismas*10 do  Prismas[i].x := Prismas[i].x - razon_de_movimiento;
for i := 1 to n_tubos*10 do tubo[i].x := Tubo[i].x - razon_de_movimiento;
Button10Click(Sender);
end;

// [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]   I N F O
procedure TForm1.Button17Click(Sender: TObject);
begin
// la aplicación está diseñada para usarse por casi cualquier persona, así
// que daré toda la información que pueda al respecto de la misma, amo hacer esto <3
Showmessage('Lo primero que debes hacer es abrir una red desde archivos, de otra forma no es posible usar el visor :)');

Showmessage('Si a la hora de abrir un diseño se ve deforme, aleja la '
+'red hasta que se vea normal, eso suele pasar :)');

Showmessage('Hay algunas cosas que pudieron mejorar, como corregir las'
    +#10#13+'deformaciones de los prismas antes de que estas sucedan'
    +#10#13+'(Cuando nos acercamos demasiado a los prismas)'
    +#10#13+'o alguno que otro inconveniente que el código pueda tener.'+#10#13+
     #10#13+'Pero en general creo que el programa funciona bien.'
    +#10#13+'(El usuario puede considerar esto como un prototipo), si'+#10#13+
            'me da tiempo le mejoraré todo lo que hay que mejorarle.');

Showmessage('Convenciones del autor:'+#10#13+#10#13+'De la tarea 4, el arrgelo de imágenes y el arreglo de líneas tienen'
+#10#13+'ambos un campo  t , éste determina el tipo de componente que un'
+#10#13+'componente es. Los posibles valores de t se traducen de la siguiente forma:'

+#10#13+'           para                       para          '
+#10#13+'  --- prismas: ---       --- tubos: ---     '
+#10#13+' 1 = distribuidores      1  = Tubos     (aquí usará el booleano True)'
+#10#13+' 2 = casas                  2 = Mangueras  (aquí usará el booleano False)'
+#10#13+' 3 = edificios'
+#10#13+' 4 = bombas'
+#10#13+' 5 = medidores'
+#10#13+' 6 = llaves');


Showmessage(' [ /\ ]    ,   [ < ]    ,    [ > ]    y   [ V ]   son herramientas extra que nos pueden ayudar '
 +'a desplazarnos por el mapa, cada uno utiliza la traslación 3D en toda la red '
 +'hacia la dirección en la que el botón indica, y esto da la ilusión de que '
+'nos movemos por la red.'+#10#13+#10#13+'Estos controles se activan y desactivan con el botón "Controles de movimiento"');

showmessage(' La manera en la que se maneja la información es la siguiente:'

+#10#13+#10#13+'Definimos una Red de prismas de tamaño N*10, donde N es el número de prismas que deseamos tener y el'
+' 10 representa los 10 puntos que cada prisma (en este caso cuadrangular) requiere.'
+' Es decir, en un arreglo de 1600 TPoint3D´S tenemos lo necesario para almacenar'
+' hasta 160 prismas, y cada 10 TPoint3D´S simbolizan un prisma particular.'
+#10#13+#10#13+'Y funciona igual para los tubos (también son prismas pero delgaditos y estirados) jajajaj');

Showmessage('Creo que lo hice todo bien, creo que todo está en orden...'+#10#13+#10#13+'Contacto:'+#10#13+
'Christian Amauri Amador Ortega  |  tel: 2224961605  |  BUAP'
+#10#13+'Rocketwave0@gmail.com  |  16aoca1e@gmail.com');
end;

// [][][][][][][][][][][][][][][][][][][][][][] ALTERNAR CONTROLES DE MOVIMIENTO
procedure TForm1.Button18Click(Sender: TObject);
begin
if(Panel3.Visible = false) then begin panel3.Visible := true; Button18.Caption := 'Desactivar controles de mov...'; end else
if (Panel3.Visible = true) then begin Panel3.Visible := false;Button18.Caption := 'Activar controles de movimiento';end;
end;

//[][][][][][][][][][][][][][][][][][][][][][][][][][][] C O N S T R U C T O R
procedure TForm1.FormCreate(Sender: TObject);
begin
// desactivamos botones, inicializamos variables, etc...
listo_para_pintar := false;  razon_de_movimiento := 1;
button1.Enabled := false; button2.Enabled := false; button3.Enabled := false;
button4.Enabled := false; button5.Enabled := false; button6.Enabled := false;
button7.Enabled := false; button8.Enabled := false; button10.Enabled := false;
button18.Enabled := false;
D := 100;
OjoAobjeto := 500;

n_prismas := 1;     n_tubos := 1;
panel3.Visible := False;
Label2.Font.Color := ClLime;
CleanImage();
Showmessage('Si tienes dudas; el botón "INFO" está para resolverlas todas :)');
end;

//[][][][][][][][][][][][][][][][][][][][][][][][][][][][][] HABILITAR PROCESOS
procedure TForm1.Habilitar();
begin
// esta funcion se llama cuando el usuario ya seleccionó una red para pintarla
button1.Enabled := true;
button2.Enabled := true;
button3.Enabled := true;
button4.Enabled := true;
button5.Enabled := true;
button6.Enabled := true;
button7.Enabled := true;
button8.Enabled := true;
button10.Enabled := true;
button18.Enabled := true;
listo_para_pintar := true;
end;

//[][][][][][][][][][][][][][][][][][][][][][][][][][][][][] LIMPIAR PANTALLA
procedure TForm1.CleanImage();
begin
image1.canvas.pen.color := clgray;
image1.canvas.brush.color := $00C2FCD3;
image1.Canvas.Rectangle(0,0,600,600);
end;

//[][][][][][][][][][][][][][][][][][][][][] LIMPIAR INFORMACIÓN (DEFECTUOSO)
Procedure TForm1.CleanData();
  var
  I : integer ;
begin
// esta función se llama si el usuario quiere pintar más de una red en una
// sola ejecución, en teoría la función limpia todo pero tiene un pequeño fallo
// (puede olvidar eliminar un par de datos) aún así es mejor que nada así que...
// desactivamos botones, inicializamos variables, etc...
listo_para_pintar := false;  razon_de_movimiento := 1;
button1.Enabled := false; button2.Enabled := false; button3.Enabled := false;
button4.Enabled := false; button5.Enabled := false; button6.Enabled := false;
button7.Enabled := false; button8.Enabled := false; button10.Enabled := false;
button18.Enabled := false;
for I := 1 to n_prismas do begin
  Prismas[i].x := 0;
  Prismas[i].y := 0;
  Prismas[i].z := 0;
end;
for I := 1 to n_prismas do begin
  Tubo[i].x := 0;
  Tubo[i].y := 0;
  Tubo[i].z := 0;
end;
n_prismas := 1;     n_tubos := 1;
panel3.Visible := False;
Label2.Font.Color := ClLime;
CleanImage();
end;

// Firma: Un Mapache :^)
end.
